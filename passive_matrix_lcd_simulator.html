<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LCD Display Emulator</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>

<body>
  <h1 style="text-align: center;">LCD Display Emulator</h1>
  <canvas id="lcdCanvas" width="300" height="300"></canvas>

  <script>
    const rows = 30;  // Number of rows in the display
    const cols = 30;  // Number of columns in the display
    const pixelSize = 10;  // Size of each pixel in the display
    // Liquid crystal values
    const maxTransparentVoltage = 1.9;
    const minOpaqueVoltage = 2.1;
    const lcdOpacitySlope = (0-1)/(minOpaqueVoltage-maxTransparentVoltage);
    const lcdOpacityIntercept = -lcdOpacitySlope * minOpaqueVoltage;
    // Let's say it takes 5ms to come to full darkness at RMS of 2.2V, 2/3 of 3.3V, kind of hard to measure unless using led / photodiode, which don't want to set up right now
    // So RMS window needs to be ... 7.5ms.
    const RMS_window_us = 7500;
    var microseconds = 0;
    // I measure 20us for voltage to settle on trace wires going into board. Don't want to deal with sub-tick stuff yet
    const tick_size_us = 50;
    // Mean squared
    const pixelSquareEntriesCount = RMS_window_us / tick_size_us;
    // Need a circular buffer
    var pixelSquareEntriesIndex = 0;


    // 2D array to store pixel voltages
    let pixelSquareEntries = Array(rows).fill().map(() => Array(cols).fill(0).map(() => Array(pixelSquareEntriesCount).fill(0)));
    let pixelMeans = Array(rows).fill().map(() => Array(cols).fill(0));
    let pixelRMSVoltages = Array(rows).fill().map(() => Array(cols).fill(0));

    // Canvas setup
    const canvas = document.getElementById('lcdCanvas');
    const ctx = canvas.getContext('2d');

    // Function to map RMS voltage to transmittance (pixel "brightness")
    function mapVoltageToBrightness(RMSVoltage) {
      // Roughly correct with crossover voltage of 2V
      return Math.max(0, Math.min(1, lcdOpacitySlope * RMSVoltage + lcdOpacityIntercept));
    }

    // Function to simulate RC filter for voltage updates
    function updatePixelVoltage(row, col, rowVoltage, colVoltage) {
      const nextSquaredEntry = (rowVoltage - colVoltage) * (rowVoltage - colVoltage);
      pixelMeans[row][col] = pixelMeans[row][col] + ((nextSquaredEntry) - pixelSquareEntries[row][col][pixelSquareEntriesIndex])/pixelSquareEntriesCount;
      pixelRMSVoltages[row][col] = Math.sqrt(pixelMeans[row][col]);
      pixelSquareEntries[row][col][pixelSquareEntriesIndex] = nextSquaredEntry;


      if (row == 5 && col == 0) {
        // Do nothing

        console.log(pixelSquareEntriesIndex, nextSquaredEntry, pixelMeans[row][col], pixelRMSVoltages[row][col]);//, pixelBrightnesses[row][col]);
        Function.prototype();
      }
    }

    // Function to draw the LCD display
    function drawDisplay() {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const rgb_brightness = Math.floor(mapVoltageToBrightness(pixelRMSVoltages[row][col]) * 255);
          if (row == 5 && col < 5 && rgb_brightness < 128) {
            Function.prototype();
          }
          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          ctx.fillStyle = `rgb(${rgb_brightness}, ${rgb_brightness}, ${rgb_brightness})`;
          ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
        }
      }
    }

    // Function to simulate the addressing of the LCD display
    function simulateAddressing(microseconds) {
      // Update each pixel based on its row and column addressing voltages
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          var rowVoltage = 0;
          var colVoltage = 0;

          if (row == 5) {
            if (Math.floor(microseconds / 5000) % 2 == 0) {
              rowVoltage = 2.2;
            }
          }
          if (col == 5) {
            if (Math.floor(microseconds / 5000) % 2 == 1) {
              colVoltage = 2.2;
            }
          }

          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          updatePixelVoltage(row, col, rowVoltage, colVoltage);
        }
      }
    }
/*
    function theAlgorithm(maxTransparentVoltage, minOpaqueVoltage, temperature, RMS_window_us, desiredOpacitiesArray) {
      // Given various constants and an array of desired opacities, emit a list of
      // (timestamp_us, rows, cols)
      // for a scheduler to work with that minimizes power drawn and does not exhibit ghosting behavior

      // Find matching columns
    }
    */

    // Main loop to continuously update the display
    function mainLoop() {
      const loopIterations = 1; //slow motion ... 16000 / tick_size_us; // 16000 ms = 60 fps
      for (let i = 0; i < loopIterations; i++) {
        simulateAddressing(microseconds);
        microseconds += tick_size_us;
        pixelSquareEntriesIndex = (pixelSquareEntriesIndex + 1) % pixelSquareEntriesCount;
      }
      drawDisplay();
      requestAnimationFrame(mainLoop);
    }

    // Start the simulation
    mainLoop();
  </script>
</body>

</html>