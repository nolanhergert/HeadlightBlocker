<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LCD Display Emulator</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>

<body>
  <h1 style="text-align: center;">LCD Display Emulator</h1>
  <canvas id="lcdCanvas" width="300" height="300"></canvas>

  <script>
    const numRows = 30;  // Number of rows in the display
    const numCols = 30;  // Number of columns in the display
    const pixelSize = 10;  // Size of each pixel in the display
    // Liquid crystal values
    const maxTransparentVoltage = 1.9;
    const minOpaqueVoltage = 2.1;
    const lcdOpacitySlope = (0-1)/(minOpaqueVoltage-maxTransparentVoltage);
    const lcdOpacityIntercept = -lcdOpacitySlope * minOpaqueVoltage;
    // Let's say it takes 5ms to come to full darkness at RMS of 2.2V, 2/3 of 3.3V, kind of hard to measure unless using led / photodiode, which don't want to set up right now
    // So RMS window needs to be ... 7.5ms.
    const RMS_window_us = 7500;
    var microseconds = 0;
    // I measure 20us for voltage to settle on trace wires going into board. Don't want to deal with sub-tick stuff yet
    const tick_size_us = 50;
    // Mean squared
    const pixelSquareEntriesCount = RMS_window_us / tick_size_us;
    // Need a circular buffer
    var pixelSquareEntriesIndex = 0;


    // 2D array to store pixel voltages
    let pixelSquareEntries = Array(numRows).fill().map(() => Array(numCols).fill(0).map(() => Array(pixelSquareEntriesCount).fill(0)));
    let pixelMeans = Array(numRows).fill().map(() => Array(numCols).fill(0));
    let pixelRMSVoltages = Array(numRows).fill().map(() => Array(numCols).fill(0));

    // Canvas setup
    const canvas = document.getElementById('lcdCanvas');
    const ctx = canvas.getContext('2d');

    // Function to map RMS voltage to transmittance (pixel "brightness")
    function mapVoltageToBrightness(RMSVoltage) {
      // Roughly correct with crossover voltage of 2V
      return Math.max(0, Math.min(1, lcdOpacitySlope * RMSVoltage + lcdOpacityIntercept));
    }

    // Function to simulate RC filter for voltage updates
    function updatePixelVoltage(row, col, rowVoltage, colVoltage) {
      const nextSquaredEntry = (rowVoltage - colVoltage) * (rowVoltage - colVoltage);
      pixelMeans[row][col] = pixelMeans[row][col] + ((nextSquaredEntry) - pixelSquareEntries[row][col][pixelSquareEntriesIndex])/pixelSquareEntriesCount;
      pixelRMSVoltages[row][col] = Math.sqrt(pixelMeans[row][col]);
      pixelSquareEntries[row][col][pixelSquareEntriesIndex] = nextSquaredEntry;


      if (row == 5 && col == 0) {
        // Do nothing

        console.log(pixelSquareEntriesIndex, nextSquaredEntry, pixelMeans[row][col], pixelRMSVoltages[row][col]);//, pixelBrightnesses[row][col]);
        Function.prototype();
      }
    }

    // Function to draw the LCD display
    function drawDisplay() {
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          const rgb_brightness = Math.floor(mapVoltageToBrightness(pixelRMSVoltages[row][col]) * 255);
          if (row == 5 && col < 5 && rgb_brightness < 128) {
            Function.prototype();
          }
          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          ctx.fillStyle = `rgb(${rgb_brightness}, ${rgb_brightness}, ${rgb_brightness})`;
          ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
        }
      }
    }

    // Function to simulate the addressing of the LCD display
    function simulateAddressing(microseconds) {
      // Update each pixel based on its row and column addressing voltages
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          var rowVoltage = 0;
          var colVoltage = 0;

          if (row == 5) {
            if (Math.floor(microseconds / 5000) % 2 == 0) {
              rowVoltage = 2.2;
            }
          }
          if (col == 5) {
            if (Math.floor(microseconds / 5000) % 2 == 1) {
              colVoltage = 2.2;
            }
          }

          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          updatePixelVoltage(row, col, rowVoltage, colVoltage);
        }
      }
    }

    /*
    function ColumnsMatch(column1, column2) {
      if (column1.length !== column2.length) {
        return false; // Arrays must have the same length
      }

      for (let i = 0; i < column1.length; i++) {
        if (column1[i] !== column2[i]) {
          return false; // Values differ
        }
      }

      return true; // Columns are identical
    }

    function theAlgorithm(maxTransparentVoltage, minOpaqueVoltage, temperature, RMS_window_us, desiredOpacitiesArray) {
      // Given various constants and an array of desired opacities, emit a list of
      // (timestamp_us, rows, cols)
      // for a scheduler to work with that minimizes power drawn and does not exhibit ghosting behavior
      const lcdUpdates = [];
      // Find matching columns
      for (let i = 1; i < numCols; i++) {
        if ()

        lcdUpdates.push({rows: rows, cols: cols, timestampUs:timestampUs});


      }

      // Hopefully we can return a local variable like this!
      return lcdUpdates;

      // TODO: Localized  Don't focus on grayscale just yet
    }

    function evaluateZeroMean(list_of_rows_cols_time_data) {
    const MicrosecondsInOne30FPSFrame = 33333; // We need to have zero mean within a reasonable time scale
    const AllowableDeviationWeightedSum = 10;
    let pixelMeans = Array(numRows).fill().map(() => Array(numCols).fill(0));
    let pixelWeightedSum = 0;
    let microsecondsSum = 0;
    for row in rows:
      for col in cols:
        for entry in list:
          if (microsecondsSum > MicrosecondsInOne30FPSFrame) break;
          pixelWeightedSum += (entry.cols[col] - entry.rows[row]) * entry.microseconds;
        }

        if (Math.abs(pixelWeightedSum) > AllowableDeviationWeightedSum) {
          // ERROR

        }



    }
*/



    // Main loop to continuously update the display
    function mainLoop() {
      const loopIterations = 1; //slow motion ... 16000 / tick_size_us; // 16000 ms = 60 fps
      for (let i = 0; i < loopIterations; i++) {
        simulateAddressing(microseconds);
        microseconds += tick_size_us;
        pixelSquareEntriesIndex = (pixelSquareEntriesIndex + 1) % pixelSquareEntriesCount;
      }
      drawDisplay();
      requestAnimationFrame(mainLoop);
    }

    // Start the simulation
    mainLoop();
  </script>
</body>

</html>