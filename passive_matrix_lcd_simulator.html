<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LCD Display Emulator</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>

<body>
  <h1 style="text-align: center;">LCD Display Emulator</h1>
  <canvas id="lcdCanvas" width="300" height="300"></canvas>

  <script>
    const rows = 30;  // Number of rows in the display
    const cols = 30;  // Number of columns in the display
    const pixelSize = 10;  // Size of each pixel in the display
    const RC_liquid_crystal = 0.2;  // RC filter time constant for brightness/transparency of liquid crystal
    var ticks = 0;

    // 2D array to store pixel voltages
    let pixelRMSVoltages = Array(rows).fill().map(() => Array(cols).fill(0));
    let pixelBrightnesses = Array(rows).fill().map(() => Array(cols).fill(1));

    // Canvas setup
    const canvas = document.getElementById('lcdCanvas');
    const ctx = canvas.getContext('2d');

    // Function to map RMS voltage to transmittance (pixel "brightness")
    function mapVoltageToBrightness(RMSVoltage) {
      // Roughly correct with crossover voltage of 2V
      return Math.max(0, Math.min(1, -25 * RMSVoltage + 50.5));
    }

    // Function to simulate RC filter for voltage updates
    function updatePixelVoltage(row, col, rowVoltage, colVoltage) {
      const previousVoltage = pixelRMSVoltages[row][col];
      const targetVoltage = rowVoltage - colVoltage;
      // RC filter equation: newV = prevV + (targetV - prevV) * (dt / RC)
      pixelRMSVoltages[row][col] = pixelRMSVoltages[row][col] + (Math.sqrt(targetVoltage * targetVoltage) - pixelRMSVoltages[row][col]) * (RC_liquid_crystal);

      if (row == 5 && col == 0) {
        // Do nothing

        console.log(previousVoltage, targetVoltage, pixelRMSVoltages[row][col]);//, pixelBrightnesses[row][col]);
        Function.prototype();
      }
    }

    // Function to draw the LCD display
    function drawDisplay() {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const rgb_brightness = Math.floor(mapVoltageToBrightness(pixelRMSVoltages[row][col]) * 255);
          if (row == 5 && col < 5 && rgb_brightness < 128) {
            Function.prototype();
          }
          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          ctx.fillStyle = `rgb(${rgb_brightness}, ${rgb_brightness}, ${rgb_brightness})`;
          ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
        }
      }
    }

    // Function to simulate the addressing of the LCD display
    function simulateAddressing(ticks) {
      // Update each pixel based on its row and column addressing voltages
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          var rowVoltage = 0;
          var colVoltage = 0;

          if (row == 5) {
            if (ticks % 2 == 0) {
              rowVoltage = 3.3;
            }
          }
          if (col == 5) {
            if (ticks % 2 == 1) {
              colVoltage = 3.3;
            }
          }

          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          updatePixelVoltage(row, col, rowVoltage, colVoltage);
        }
      }

      drawDisplay();
    }

    // Main loop to continuously update the display
    function mainLoop() {
      simulateAddressing(ticks);
      requestAnimationFrame(mainLoop);
      ticks++;
    }

    // Start the simulation
    mainLoop();
  </script>
</body>

</html>