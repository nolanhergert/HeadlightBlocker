<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LCD Display Emulator</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>

<body>
  <h1 style="text-align: center;">LCD Display Emulator</h1>
  <canvas id="lcdCanvas" width="300" height="300"></canvas>

  <script>
    const rows = 30;  // Number of rows in the display
    const cols = 30;  // Number of columns in the display
    const pixelSize = 10;  // Size of each pixel in the display
    const RC_cap = 0.01;  // RC filter time constant for capacitive voltage
    const RC_brightness = 0.2;  // RC filter time constant for brightness/transparency of liquid crystal
    const dt = 0.01;  // Time step for updates
    var time = 0;

    // 2D array to store pixel voltages
    let pixelVoltages = Array(rows).fill().map(() => Array(cols).fill(0));
    let pixelBrightnesses = Array(rows).fill().map(() => Array(cols).fill(1));

    // Canvas setup
    const canvas = document.getElementById('lcdCanvas');
    const ctx = canvas.getContext('2d');

    // Function to map voltage to RMV voltage to transmittance (pixel darkness)
    function mapVoltageToBrightness(voltage) {
      // Roughly correct with crossover voltage of 2V
      return Math.max(0, Math.min(1, -5 * Math.sqrt(voltage * voltage) + 10.5));
    }

    // Function to simulate RC filter for voltage updates
    function updatePixelVoltage(row, col, rowVoltage, colVoltage) {
      const previousVoltage = pixelVoltages[row][col];
      const targetVoltage = rowVoltage - colVoltage;
      // RC filter equation: newV = prevV + (targetV - prevV) * (dt / RC)
      pixelVoltages[row][col] = previousVoltage + (targetVoltage - previousVoltage) * (dt / RC_cap);
      pixelBrightnesses[row][col] = pixelBrightnesses[row][col] + (mapVoltageToBrightness(pixelVoltages[row][col]) - pixelBrightnesses[row][col]) * (dt / RC_brightness);

      if (row == 5) {
        // Do nothing
        Function.prototype();
      }
    }

    // Function to draw the LCD display
    function drawDisplay() {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const rgb_brightness = Math.floor(pixelBrightnesses[row][col] * 255);
          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          ctx.fillStyle = `rgb(${rgb_brightness}, ${rgb_brightness}, ${rgb_brightness})`;
          ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
        }
      }
    }

    // Function to simulate the addressing of the LCD display
    function simulateAddressing(time) {
      // Update each pixel based on its row and column addressing voltages
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          var rowVoltage = 0;
          var colVoltage = 0;

          if (row == 5) {
            if (Math.trunc(time * 100) % 2 == 0) {
              rowVoltage = 3.3;
            }
          }
          if (col == 5) {
            if (Math.trunc(time * 100) % 2 == 1) {
              colVoltage = 3.3;
            }
          }

          if (row == 5) {
            // Do nothing
            Function.prototype();
          }
          updatePixelVoltage(row, col, rowVoltage, colVoltage);
        }
      }

      drawDisplay();
    }

    // Main loop to continuously update the display
    function mainLoop() {
      simulateAddressing(time);
      console.log(pixelBrightnesses[6][5]);
      requestAnimationFrame(mainLoop);
      time += dt;
    }

    // Start the simulation
    mainLoop();
  </script>
</body>

</html>